#!/usr/bin/env python
#
# Copyright (c) 2019 Sine Nomine Associates
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
# THE SOFTWARE IS PROVIDED 'AS IS' AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

from __future__ import print_function

import argparse
import os
import re
import sys
import string
import json

try:
    # python3
    from configparser import ConfigParser
    from configparser import NoSectionError
    from configparser import NoOptionError
except ImportError:
    # python2
    from ConfigParser import SafeConfigParser as ConfigParser
    from ConfigParser import NoSectionError
    from ConfigParser import NoOptionError

verbose = False
dryrun = False

VERSION = 'v0.8'
VIRTDIR = '~/virt'
DESC  = 'Install and remove sets of guests on a local hypervisor using cloud-init images.'
USAGE = '''\
virt-lab [<options>] <command> [<name>]

Commands:
  create <name>     create guests
  destroy <name>    destroy guests
  start <name>      start guests
  stop <name>       shutdown guests
  info <name>       show lab and guest status
  inventory <name>  ansible dynamic inventory
  list              list guest sets
  help              show help
  version           show version
'''
DEFAULTS = {
    'autostart': True,
    'bridge': 'virbr0',
    'cpus': None,
    'disksize': None,
    'distro': 'centos7',
    'domain': 'example.com',
    'feature': None,
    'gateway': '192.168.122.1',
    'graphics': None,
    'guests': '3',
    'imagedir': None,
    'image': None,
    'key': None,
    'mac': None,
    'memory': None,
    'namefmt': '{lab}{guest:02d}',
    'port': None,
    'scriptname': None,
    'timezone': None,
    'user': None,
    'vardir': VIRTDIR + '/vars',
    'vmdir': VIRTDIR + '/vms',
    'scriptdir': VIRTDIR + '/scripts',
    'playbookdir': VIRTDIR + '/playbooks',
}
TEMPLATES = ('postcreate', 'postdestroy')
PATHNAMES = ('key', 'imagedir', 'scriptname', 'vmdir', 'vardir',
             'scriptdir', 'playbookdir', 'postcreate', 'postdestroy')

def trace(msg):
    if verbose:
        sys.stdout.write('[trace]: %s\n' % msg)

def info(msg):
    sys.stdout.write('[info]: %s\n' % msg)

def warn(msg):
    sys.stdout.write('[warn]: %s\n' % msg)

def error(msg):
    sys.stderr.write('[error]: %s\n' % msg)

def die(msg):
    sys.stderr.write('[fatal]: %s\n' % msg)
    sys.exit(1)

def mkdirp(path):
    if not os.path.exists(path):
        os.makedirs(path)

def shellquote(s):
    """Return a shell-escaped string."""
    s = str(s)
    if not s:
        return "''"
    m = re.search(r'[^a-zA-Z0-9_:\-\./]', s)
    if m:
        s = "'" + s.replace("'", "'\"'\"'") + "'"
    return s

def run(args):
    """Run a command."""
    if isinstance(args, (list, tuple)):
        cmdline = ' '.join([shellquote(a) for a in args])
    else:
        cmdline = str(args)
    if dryrun:
        trace('Skipping: %s' % cmdline)
        return 0
    trace('Running: %s' % cmdline)
    rc = os.system(cmdline)
    return rc

def parse_sequence(s):
    """Parse a string containing a sequence of numbers, ignoring
    white space and expanding ranges in the form of <a>..<b>.

    Examples:
       ''       -> []
       '1'      -> [1]
       '1,2,3'  -> [1, 2, 3]
       '1..3'   -> [1, 2, 3]
       '1,2..3' -> [1, 2, 3]
       '2,2'    -> [2]
    """
    seq = []
    for f in s.split(','):
        f = f.strip()
        if not f:
            continue
        m = re.match(r'(\d+)$', f)
        if m:
            seq.append(int(m.group(1)))
            continue
        m = re.match(r'(\d+)\s*(\.\.|:|-)\s*(\d+)$', f)
        if m:
            a = int(m.group(1))
            b = int(m.group(3))
            if a <= b:
                seq.extend(list(range(a, b+1)))
                continue
        raise ValueError('Invalid sequence value: "%s"' % f)
    return sorted(set(seq))

class VirshError(Exception):
    pass

def virsh(command, *options):
    args = ['virsh', command]
    args.extend(list(options))
    cmdline = ' '.join([shellquote(a) for a in args])
    pipe = os.popen(cmdline + ' 2>&1')
    if not pipe:
        raise VirshError('Failed to run command: %s' % cmdline)
    output = pipe.read()
    rc = pipe.close()
    if rc is not None and rc != 0:
        raise VirshError('Error while running command: %s, rc=%d' % (cmdline, rc))
    return output


class Formatter(string.Formatter):
    def __init__(self, lab):
        self.lab = lab

    def get_value(self, key, args, kwargs):
        return self.lab.get(key)

class Variables:
    def __init__(self, path):
        self.path = path
        self.vars = {}
        self.load()

    def load(self):
        if os.path.exists(self.path):
            with open(self.path) as f:
                self.vars = json.load(f)

    def save(self):
        mkdirp(os.path.dirname(self.path))
        with open(self.path, 'w') as f:
            json.dump(self.vars, f)

    def remove(self):
        try:
            os.unlink(self.path)
        except:
            pass

    def get(self, name):
        return self.vars.get(name, None)

    def set(self, name, value):
        self.vars[name] = value
        self.save()

class Lab:

    def __init__(self, name, args, config):
        m = re.search(r'[^a-zA-Z0-9_]', name)
        if m:
            die('Invalid lab name.')
        self.name = name
        self.values = {}
        self.args = args
        self.config = config
        self.vars = Variables(os.path.join(self.vardir, 'labs', self.name + '.json'))
        # Set env variables for external commands.
        os.environ['VIRTLAB_NAME'] = self.name
        for key in DEFAULTS.keys():
            value = self.get(key)
            os.environ['VIRTLAB_' + key.upper()] = str(value) if value else ''

    def guests(self):
        nguests = int(self.get('guests'))
        for number in range(1, nguests+1):
            yield Guest(self, number)

    def __getattr__(self, name):
        value = self.get(name)
        return value

    def get(self, name):
        if not name in self.values:
            self.values[name] = self.get_value(name)
        return self.values[name]

    def get_value(self, name):
        if name == 'status':
            return self.get_status()
        value = None
        if value is None:
            value = self.get_arg_value(name)
        if value is None:
            value = self.get_cfg_value(name)
        if value is None:
            value = self.get_global_value(name)
        if value is None:
            value = DEFAULTS.get(name, None)
        if value is not None:
            if name in TEMPLATES:
                value = self.expand_string(value)
            if name in PATHNAMES:
                value = os.path.expanduser(value)
        return value

    def get_status(self):
        status = self.vars.get('status')
        if status is None:
            status = 'inactive'
            self.vars.set('status', status)
        return status

    def get_arg_value(self, name):
        return getattr(self.args, name, None)

    def get_cfg_value(self, name):
        value = None
        try:
            value = self.config.get(self.name, name)
        except NoSectionError:
            die('Lab name not found in config file %s' % (self.args.config))
        except NoOptionError:
            pass
        return value

    def get_global_value(self, name):
        try:
            value = self.config.get('.global', name)
        except (NoSectionError, NoOptionError):
            value = None
        return value

    def expand_string(self, value):
        formatter = Formatter(self)
        value = formatter.format(value)
        return value

    def inventory(self):
        """Generate an ansible dynamic inventory for this lab."""

        inventory = {}
        guests = {}
        for guest in self.guests():
            guests[guest.number] = guest.hostname

        # Expand the host groups subsection, if one.
        groups = {}
        grouped = set()
        if self.config.has_section(self.name + '.groups'):
            for name,value in self.config.items(self.name + '.groups'):
                if value == '*': # expand wildcard
                    value = '1..%d' % len(guests)
                groups[name] = [guests[i] for i in parse_sequence(value)]
                grouped.update(groups[name])
        groups['ungrouped'] = list(set(guests.values()) - grouped)

        # Set our host groups.
        for name in groups:
            inventory[name] = {'hosts': groups[name] }
        inventory['all'] = {'children': list(groups.keys()) }

        # Set our host vars.
        inventory['_meta'] = {'hostvars': {}}
        for guest in self.guests():
            inventory['_meta']['hostvars'][guest.hostname] = {}
            #if guest.ip:
            #    inventory['_meta']['hostvars'][hostname]['ansible_host'] = guest.ip

        return inventory

class Guest:

    def __init__(self, lab, number):
        self.dominfo = None
        self.lab = lab
        self.number = number
        name = self.get_cfg_value('name')
        if name is None:
            name = lab.namefmt.format(lab=lab.name, guest=number)
        self.name = name
        self.vars = Variables(os.path.join(self.vardir, 'guests', self.name + '.json'))

    def __getattr__(self, name):
        value = None
        if name == 'status':
            value = self.get_status()
            self.status = value
        if name == 'mac':
            value = self.get_mac()
            self.mac = value
        if name == 'ip':
            value = self.get_ip_addr()
            self.ip = value
        if name == 'hostname':
            value = '%s.%s' % (self.name, self.domain)
            self.hostname = value
        if value is None:
            value = self.get_cfg_value(name)
        if value is None:
            value = self.lab.get(name)
        trace('%s: %12s = %s' % (self.name, name, value))
        return value

    def get_status(self):
        lab = self.vars.get('lab')
        dominfo = self.domain_info()
        if dominfo and lab == self.lab.name:
            status = dominfo['State']
        else:
            status = ''
        return status

    def get_mac(self):
        if self.domain_exists():
            mac = self.domain_mac_addr()
        else:
            mac = self.vars.get('mac')
        return mac

    def get_ip_addr(self):
        lab = self.vars.get('lab')
        if lab == self.lab.name:
            ip = self.domain_ip_addr()
        else:
            ip = ''
        return ip

    def get_cfg_value(self, name):
        try:
            section = '%s.%d' % (self.lab.name, self.number)
            value = self.lab.config.get(section, name)
        except (NoSectionError, NoOptionError):
            value = None
        return value

    def create(self):
        if self.domain_exists():
            lab = self.vars.get('lab')
            if lab and lab != self.lab.name:
                warn('Skipping %s: domain already exists for lab %s.' % (self.name, lab))
            else:
                warn('Skipping %s: domain already exists.' % self.name)
            return

        def flag(switch, value):
            if value:
                args.append(switch)

        def opt(switch, value):
            if value is not None:
                args.append(switch)
                args.append(value)

        args = ['kvm-install-vm', 'create']
        flag('-v', verbose)
        flag('-a', self.autostart)
        opt('-b', self.bridge)
        opt('-c', self.cpus)
        opt('-d', self.disksize)
        opt('-D', self.domain)
        opt('-f', self.feature)
        opt('-g', self.graphics)
        opt('-i', self.image)
        opt('-k', self.key)
        opt('-l', self.imagedir)
        opt('-L', self.vmdir)
        opt('-m', self.memory)
        opt('-M', self.mac)
        opt('-p', self.port)
        opt('-s', self.scriptname)
        opt('-t', self.distro)
        opt('-T', self.timezone)
        opt('-u', self.user)
        args.append(self.name)

        info('creating guest %s' % self.name)
        rc = run(args)
        if rc != 0:
            die('Failed to create guest %s' % (self.name))
        self.vars.set('lab', self.lab.name)
        self.vars.set('mac', self.domain_mac_addr())
        self.vars.set('ip', self.domain_ip_addr())

    def destroy(self, purge):
        lab = self.vars.get('lab')
        if lab and lab != self.lab.name:
            warn('Skipping %s: domain associated with lab %s.' % (self.name, lab))
            return
        info('destroying guest %s' % self.name)
        run(['kvm-install-vm', 'remove', self.name])
        self.vars.set('lab', None)
        if purge:
            self.vars.remove()

    def domain_info(self):
        if self.dominfo is None:
            dominfo = {}
            try:
                for line in virsh('dominfo', self.name).splitlines():
                    if not line:
                        continue
                    key,value = line.split(':', 1)
                    key = key.strip()
                    value = value.strip()
                    dominfo[key] = value
            except VirshError:
                return None
            self.dominfo = dominfo
        return self.dominfo

    def domain_exists(self):
        """Return True if domain exists."""
        return self.domain_info() is not None

    def domain_running(self):
        """Return True if domain is running."""
        return self.domain_exists() and self.domain_info()['State'] == 'running'

    def domain_start(self):
        if not self.domain_exists():
            error('Domain %s does not exist.' % self.name)
            return
        if self.domain_running():
            trace('Skipping start; domain %s is already running.' % self.name)
            return
        trace('Starting domain %s' % self.name)
        try:
            output = virsh('start', self.name)
            info(output.strip())
        except VirshError:
            error('Failed to start %s' % self.name)

    def domain_stop(self):
        if not self.domain_exists():
            trace('Skipping stop; domain %s does not exist' % self.name)
            return
        if not self.domain_running():
            trace('Skipping stop; domain %s is not running' % self.name)
            return
        trace('Stopping domain %s' % self.name)
        try:
            output = virsh('shutdown', self.name)
            info(output.strip())
        except VirshError:
            error('Failed to stop %s' % self.name)

    def domain_mac_addr(self):
        """Return the first mac address in the domain definition, if one."""
        try:
            text = virsh('dumpxml', self.name)
            for line in text.splitlines():
                m = re.search(r"<mac address='([0-9a-fA-F:]+)'/>", line)
                if m:
                    mac = m.group(1)
                    trace('guest %s has mac %s' % (self.name, mac))
                    return m.group(1)
        except VirshError:
            pass
        trace('guest %s: mac not found' % self.name)
        return None

    def domain_ip_addr(self):
        """Attempt to find the ip address of this guest."""
        # We peak into the libvirt file to find the ip address instead
        # of using domifaddr, which is not ideal, but kvm_install_vm already
        # retried until the ip address was written to the libvirt dnsmasq file.
        try:
            with open('/var/lib/libvirt/dnsmasq/%s.status' % (self.bridge)) as f:
                status = json.load(f)
            for s in status:
                if s['mac-address'] == self.mac:
                    ip = s['ip-address']
                    trace('guest %s has ip %s' % (self.name, ip))
                    return ip
        except FileNotFoundError:
            pass
        trace('guest %s: ip not found' % self.name)
        return None

class VirtLab:

    def __init__(self):
        self._command = ''
        self._config = None
        self._args = argparse.Namespace(
            verbose=False,
            dryrun=False,
            purge=False,
            config=None)

    def _progname(self):
        """Subcommand program name."""
        return "%s %s" % (os.path.basename(sys.argv[0]), self._command)

    def _parse_args(self, parser):
        """Parse subcommand arguments."""
        self._args = parser.parse_args(sys.argv[2:], self._args)
        global verbose
        global dryrun
        verbose = self._args.verbose
        dryrun = self._args.dryrun

    def _read_config(self):
        """Read the config file

        When the file is specified with the --config option, try to read that
        file only or fail.  When the config file is not specified, try to read
        virt-lab.cfg in the current directory, and if not found, try to read
        virt-lab.cfg in the home directory.
        """
        self._config = ConfigParser()
        config = self._args.config
        if config:
            files = self._config.read([config])
            if not files:
                die('Unable to read config file %s.' % (config))
        else:
            config = 'virt-lab.cfg'
            files = self._config.read([config])
            if not files:
                config = os.path.expanduser('~/virt-lab.cfg')
                files = self._config.read([config])
                if not files:
                    die('Unable to read config file.')

    def _unknown(self):
        die('Unknown command: %s' % sys.argv[1])

    def help(self):
        """Print usage string."""
        print('usage:', USAGE)
        print(DESC)

    def version(self):
        """Print version string."""
        print('virt-lab', VERSION)

    def create(self):
        """Create the virtual lab guests."""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=self.create.__doc__)
        parser.add_argument('name')
        parser.add_argument('-v', '--verbose', action='store_true')
        parser.add_argument('-n', '--dryrun', action='store_true')
        parser.add_argument('-c', '--config')
        for key in sorted(DEFAULTS.keys()):
            if not isinstance(DEFAULTS[key], bool):
                parser.add_argument('--'+key)
        self._parse_args(parser)
        self._read_config()

        lab = Lab(self._args.name, self._args, self._config)
        for guest in lab.guests():
            guest.create()
        if lab.postcreate:
            rc = run(lab.postcreate)
            if rc != 0:
                die('post-create command failed: %s; rc=%d' % (lab.postcreate, rc))
        lab.vars.set('status', 'active')

    def destroy(self):
        """Destroy the virtual lab guests."""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=self.destroy.__doc__)
        parser.add_argument('name')
        parser.add_argument('-v', '--verbose', action='store_true')
        parser.add_argument('-n', '--dryrun', action='store_true')
        parser.add_argument('-c', '--config')
        parser.add_argument('--purge', action='store_true')
        self._parse_args(parser)
        self._read_config()

        lab = Lab(self._args.name, self._args, self._config)
        for guest in lab.guests():
            guest.destroy(self._args.purge)
        if lab.postdestroy:
            rc = run(lab.postdestroy)
            if rc != 0:
                die('post-destroy command failed: %s; rc=%d' % (lab.postdestroy, rc))
        lab.vars.set('status', 'inactive')

    def start(self):
        """Start the virtual lab guests."""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=self.start.__doc__)
        parser.add_argument('name')
        parser.add_argument('-v', '--verbose', action='store_true')
        parser.add_argument('-n', '--dryrun', action='store_true')
        parser.add_argument('-c', '--config')
        self._parse_args(parser)
        self._read_config()

        lab = Lab(self._args.name, self._args, self._config)
        for guest in lab.guests():
            guest.domain_start()
        lab.vars.set('status', 'active')

    def stop(self):
        """Stop the virtual lab guests."""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=self.stop.__doc__)
        parser.add_argument('name')
        parser.add_argument('-v', '--verbose', action='store_true')
        parser.add_argument('-n', '--dryrun', action='store_true')
        parser.add_argument('-c', '--config')
        self._parse_args(parser)
        self._read_config()

        lab = Lab(self._args.name, self._args, self._config)
        for guest in lab.guests():
            guest.domain_stop()
        lab.vars.set('status', 'inactive')

    def info(self):
        """Show virtual lab and guest info."""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=self.list.__doc__)
        parser.add_argument('name')
        self._parse_args(parser)
        self._read_config()

        out = sys.stdout
        lab = Lab(self._args.name, self._args, self._config)
        out.write('name: %s\n' % lab.name)
        out.write('status: %s\n' % lab.status)
        if lab.desc:
            out.write('desc: %s\n' % lab.desc)
        out.write('guests:\n')
        for guest in lab.guests():
            out.write('  - {name:%s' % guest.name)
            if guest.status:
                out.write(', status:%s' % guest.status)
            if guest.distro:
                out.write(', distro:%s' % guest.distro)
            if guest.ip:
                out.write(', ip:%s' % guest.ip)
            out.write('}\n')

    def list(self):
        """List virtual labs."""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=self.list.__doc__)
        parser.add_argument('-v', '--verbose', action='store_true')
        parser.add_argument('-a', '--active', action='store_true')
        parser.add_argument('--no-heading', action='store_true')
        parser.add_argument('-c', '--config')
        self._parse_args(parser)
        self._read_config()

        def escape(s):
            if s is None:
                s = ''
            return s

        out = sys.stdout
        sep = '-' * 12
        if not self._args.no_heading:
            out.write('%-12s %-12s %s\n' % ('name', 'status', 'description'))
            out.write('%-12s %-12s %s\n' % (sep, sep, sep))
        for section in self._config.sections():
            if '.' in section:
                continue # skip subsections
            name = section
            lab = Lab(name, self._args, self._config)
            if self._args.active and lab.status != 'active':
                continue # skip inactive when --active is given
            out.write('%-12s %-12s %s\n' % (lab.name, lab.status, escape(lab.desc)))

    def inventory(self):
        """Ansible dynamic inventory."""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=self.list.__doc__)
        parser.add_argument('-c', '--config')
        parser.add_argument('name')
        self._parse_args(parser)
        self._read_config()

        lab = Lab(self._args.name, self._args, self._config)
        json.dump(lab.inventory(), sys.stdout)

    def main(self):
        """Main return for virt-lab"""
        parser = argparse.ArgumentParser(
            prog=self._progname(),
            description=DESC,
            usage=USAGE)
        parser.add_argument('command', help='subcommand to run')
        args = parser.parse_args(sys.argv[1:2], self._args)
        self._command = args.command
        if self._command.startswith('_'):
            self._command = '_unknown'
        getattr(self, self._command, self._unknown)()


if __name__ == '__main__':
    VirtLab().main()
